
module.exports = {

  getDefaultProps: function () {
    return {
      _baseroute: '',
      _on: function (fn) {
        window.addEventListener('hashchange', fn)
      },
      _off: function (fn) {
        window.removeEventListener('hashchange', fn)
      },
      _path: function (path) {
        if (arguments.length === 1) {
          window.location.hash = '#' + path
        } else {
          return window.location.hash.slice(1)
        }
      },
      goTo: null
    }
  },
  getInitialState: function () {
    return {
      _route: ''
    }
  },

  componentWillMount: function () {
    if (this.props.goTo) {
      // I'm not the top router
      var cancel = this.enter && this.enter()
      if (cancel) return
    }

    this.props._on(this.pathchange)

    this.setRouteFromPath()
  },
  componentWillUnmount: function () {
    this.props._off(this.pathchange)
  },
  /** Do we need this for something?
  componentDidUpdate: function (oprops, ostate) {
    if (ostate._route === this.state._route) return
  },
  **/

  pathchange: function () {
    this.setRouteFromPath()
  },

  setRouteFromPath: function () {
    // check the current url, if there's information for me there then load
    // that into the _route state
    var path = this.props._path()
    if (path.indexOf(this.props._baseroute) === -1) {
      // left this path. we will soon be destructed.
      return
    }
    var hash = path.slice(this.props._baseroute.length)
    if (hash.length && hash[0] === '/') hash = hash.slice(1)
    var part = hash.split('/', 1)[0]
    this.setState({_route: part})
  },

  goTo: function (route, global, force) {
    var full, part
    if (global) {
      if (route.indexOf(this.props._baseroute) !== 0) {
        return this.props.goTo(route, global, force)
      }
      full = route
      part = route.slice(this.props._baseroute.length).split('/', 1)[0]
    } else {
      full = this.props._baseroute
      if (full.length && full[full.length-1] !== '/' && route.length && route[0] !== '/') {
        full += '/'
      }
      full += route
      part = route.split('/', 1)[0]
    }

    var switching = part !== this.state._route
    if (switching && !force) {
      /** Not sure how this should work exactly. It should probably be async....
      if (this.refs._outlet.leave && !this.refs._outlet.leave()) {
        console.log('Routing cancelled by current outlet', this.state._route, route)
        return
      }
      **/
    }
    this.props._path(full)
  },

  outlet: function () {
    var route = this.routes[this.state._route]
    if (!route && this.routes['*']) route = this.routes['*']
    if (!route) {
      throw new Error('Invalid router state envountered; no good route here...' + this.state._route)
    }
    if ('string' === typeof route) {
      route = this.routes[route] // redirect... not quite as awesome as might be... this should be a replacestate
    }
    if (Array.isArray(route)) {
      args = route[1].call(this)
      cls = route[0]
    } else {
      args = {}
      cls = route
    }
    var context = this.props.ctx ? _.extend({}, this.props.ctx) : {}
    if (this.context) {
      _.extend(context, this.context())
    }
    args.ctx = context
    args.goTo = this.goTo
    args._baseroute = this.props._baseroute + '/' + this.state._route

    return cls(args)
  },
}

